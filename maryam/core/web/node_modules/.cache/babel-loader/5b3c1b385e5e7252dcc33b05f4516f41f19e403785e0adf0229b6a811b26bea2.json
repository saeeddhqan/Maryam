{"ast":null,"code":"import getCompositeRect from \"./dom-utils/getCompositeRect.js\";\nimport getLayoutRect from \"./dom-utils/getLayoutRect.js\";\nimport listScrollParents from \"./dom-utils/listScrollParents.js\";\nimport getOffsetParent from \"./dom-utils/getOffsetParent.js\";\nimport getComputedStyle from \"./dom-utils/getComputedStyle.js\";\nimport orderModifiers from \"./utils/orderModifiers.js\";\nimport debounce from \"./utils/debounce.js\";\nimport validateModifiers from \"./utils/validateModifiers.js\";\nimport uniqueBy from \"./utils/uniqueBy.js\";\nimport getBasePlacement from \"./utils/getBasePlacement.js\";\nimport mergeByName from \"./utils/mergeByName.js\";\nimport detectOverflow from \"./utils/detectOverflow.js\";\nimport { isElement } from \"./dom-utils/instanceOf.js\";\nimport { auto } from \"./enums.js\";\nvar INVALID_ELEMENT_ERROR = 'Popper: Invalid reference or popper argument provided. They must be either a DOM element or virtual element.';\nvar INFINITE_LOOP_ERROR = 'Popper: An infinite loop in the modifiers cycle has been detected! The cycle has been interrupted to prevent a browser crash.';\nvar DEFAULT_OPTIONS = {\n  placement: 'bottom',\n  modifiers: [],\n  strategy: 'absolute'\n};\nfunction areValidElements() {\n  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n    args[_key] = arguments[_key];\n  }\n  return !args.some(function (element) {\n    return !(element && typeof element.getBoundingClientRect === 'function');\n  });\n}\nexport function popperGenerator(generatorOptions) {\n  if (generatorOptions === void 0) {\n    generatorOptions = {};\n  }\n  var _generatorOptions = generatorOptions,\n    _generatorOptions$def = _generatorOptions.defaultModifiers,\n    defaultModifiers = _generatorOptions$def === void 0 ? [] : _generatorOptions$def,\n    _generatorOptions$def2 = _generatorOptions.defaultOptions,\n    defaultOptions = _generatorOptions$def2 === void 0 ? DEFAULT_OPTIONS : _generatorOptions$def2;\n  return function createPopper(reference, popper, options) {\n    if (options === void 0) {\n      options = defaultOptions;\n    }\n    var state = {\n      placement: 'bottom',\n      orderedModifiers: [],\n      options: Object.assign({}, DEFAULT_OPTIONS, defaultOptions),\n      modifiersData: {},\n      elements: {\n        reference: reference,\n        popper: popper\n      },\n      attributes: {},\n      styles: {}\n    };\n    var effectCleanupFns = [];\n    var isDestroyed = false;\n    var instance = {\n      state: state,\n      setOptions: function setOptions(setOptionsAction) {\n        var options = typeof setOptionsAction === 'function' ? setOptionsAction(state.options) : setOptionsAction;\n        cleanupModifierEffects();\n        state.options = Object.assign({}, defaultOptions, state.options, options);\n        state.scrollParents = {\n          reference: isElement(reference) ? listScrollParents(reference) : reference.contextElement ? listScrollParents(reference.contextElement) : [],\n          popper: listScrollParents(popper)\n        }; // Orders the modifiers based on their dependencies and `phase`\n        // properties\n\n        var orderedModifiers = orderModifiers(mergeByName([].concat(defaultModifiers, state.options.modifiers))); // Strip out disabled modifiers\n\n        state.orderedModifiers = orderedModifiers.filter(function (m) {\n          return m.enabled;\n        }); // Validate the provided modifiers so that the consumer will get warned\n        // if one of the modifiers is invalid for any reason\n\n        if (process.env.NODE_ENV !== \"production\") {\n          var modifiers = uniqueBy([].concat(orderedModifiers, state.options.modifiers), function (_ref) {\n            var name = _ref.name;\n            return name;\n          });\n          validateModifiers(modifiers);\n          if (getBasePlacement(state.options.placement) === auto) {\n            var flipModifier = state.orderedModifiers.find(function (_ref2) {\n              var name = _ref2.name;\n              return name === 'flip';\n            });\n            if (!flipModifier) {\n              console.error(['Popper: \"auto\" placements require the \"flip\" modifier be', 'present and enabled to work.'].join(' '));\n            }\n          }\n          var _getComputedStyle = getComputedStyle(popper),\n            marginTop = _getComputedStyle.marginTop,\n            marginRight = _getComputedStyle.marginRight,\n            marginBottom = _getComputedStyle.marginBottom,\n            marginLeft = _getComputedStyle.marginLeft; // We no longer take into account `margins` on the popper, and it can\n          // cause bugs with positioning, so we'll warn the consumer\n\n          if ([marginTop, marginRight, marginBottom, marginLeft].some(function (margin) {\n            return parseFloat(margin);\n          })) {\n            console.warn(['Popper: CSS \"margin\" styles cannot be used to apply padding', 'between the popper and its reference element or boundary.', 'To replicate margin, use the `offset` modifier, as well as', 'the `padding` option in the `preventOverflow` and `flip`', 'modifiers.'].join(' '));\n          }\n        }\n        runModifierEffects();\n        return instance.update();\n      },\n      // Sync update – it will always be executed, even if not necessary. This\n      // is useful for low frequency updates where sync behavior simplifies the\n      // logic.\n      // For high frequency updates (e.g. `resize` and `scroll` events), always\n      // prefer the async Popper#update method\n      forceUpdate: function forceUpdate() {\n        if (isDestroyed) {\n          return;\n        }\n        var _state$elements = state.elements,\n          reference = _state$elements.reference,\n          popper = _state$elements.popper; // Don't proceed if `reference` or `popper` are not valid elements\n        // anymore\n\n        if (!areValidElements(reference, popper)) {\n          if (process.env.NODE_ENV !== \"production\") {\n            console.error(INVALID_ELEMENT_ERROR);\n          }\n          return;\n        } // Store the reference and popper rects to be read by modifiers\n\n        state.rects = {\n          reference: getCompositeRect(reference, getOffsetParent(popper), state.options.strategy === 'fixed'),\n          popper: getLayoutRect(popper)\n        }; // Modifiers have the ability to reset the current update cycle. The\n        // most common use case for this is the `flip` modifier changing the\n        // placement, which then needs to re-run all the modifiers, because the\n        // logic was previously ran for the previous placement and is therefore\n        // stale/incorrect\n\n        state.reset = false;\n        state.placement = state.options.placement; // On each update cycle, the `modifiersData` property for each modifier\n        // is filled with the initial data specified by the modifier. This means\n        // it doesn't persist and is fresh on each update.\n        // To ensure persistent data, use `${name}#persistent`\n\n        state.orderedModifiers.forEach(function (modifier) {\n          return state.modifiersData[modifier.name] = Object.assign({}, modifier.data);\n        });\n        var __debug_loops__ = 0;\n        for (var index = 0; index < state.orderedModifiers.length; index++) {\n          if (process.env.NODE_ENV !== \"production\") {\n            __debug_loops__ += 1;\n            if (__debug_loops__ > 100) {\n              console.error(INFINITE_LOOP_ERROR);\n              break;\n            }\n          }\n          if (state.reset === true) {\n            state.reset = false;\n            index = -1;\n            continue;\n          }\n          var _state$orderedModifie = state.orderedModifiers[index],\n            fn = _state$orderedModifie.fn,\n            _state$orderedModifie2 = _state$orderedModifie.options,\n            _options = _state$orderedModifie2 === void 0 ? {} : _state$orderedModifie2,\n            name = _state$orderedModifie.name;\n          if (typeof fn === 'function') {\n            state = fn({\n              state: state,\n              options: _options,\n              name: name,\n              instance: instance\n            }) || state;\n          }\n        }\n      },\n      // Async and optimistically optimized update – it will not be executed if\n      // not necessary (debounced to run at most once-per-tick)\n      update: debounce(function () {\n        return new Promise(function (resolve) {\n          instance.forceUpdate();\n          resolve(state);\n        });\n      }),\n      destroy: function destroy() {\n        cleanupModifierEffects();\n        isDestroyed = true;\n      }\n    };\n    if (!areValidElements(reference, popper)) {\n      if (process.env.NODE_ENV !== \"production\") {\n        console.error(INVALID_ELEMENT_ERROR);\n      }\n      return instance;\n    }\n    instance.setOptions(options).then(function (state) {\n      if (!isDestroyed && options.onFirstUpdate) {\n        options.onFirstUpdate(state);\n      }\n    }); // Modifiers have the ability to execute arbitrary code before the first\n    // update cycle runs. They will be executed in the same order as the update\n    // cycle. This is useful when a modifier adds some persistent data that\n    // other modifiers need to use, but the modifier is run after the dependent\n    // one.\n\n    function runModifierEffects() {\n      state.orderedModifiers.forEach(function (_ref3) {\n        var name = _ref3.name,\n          _ref3$options = _ref3.options,\n          options = _ref3$options === void 0 ? {} : _ref3$options,\n          effect = _ref3.effect;\n        if (typeof effect === 'function') {\n          var cleanupFn = effect({\n            state: state,\n            name: name,\n            instance: instance,\n            options: options\n          });\n          var noopFn = function noopFn() {};\n          effectCleanupFns.push(cleanupFn || noopFn);\n        }\n      });\n    }\n    function cleanupModifierEffects() {\n      effectCleanupFns.forEach(function (fn) {\n        return fn();\n      });\n      effectCleanupFns = [];\n    }\n    return instance;\n  };\n}\nexport var createPopper = /*#__PURE__*/popperGenerator(); // eslint-disable-next-line import/no-unused-modules\n\nexport { detectOverflow };","map":{"version":3,"names":["getCompositeRect","getLayoutRect","listScrollParents","getOffsetParent","getComputedStyle","orderModifiers","debounce","validateModifiers","uniqueBy","getBasePlacement","mergeByName","detectOverflow","isElement","auto","INVALID_ELEMENT_ERROR","INFINITE_LOOP_ERROR","DEFAULT_OPTIONS","placement","modifiers","strategy","areValidElements","_len","arguments","length","args","Array","_key","some","element","getBoundingClientRect","popperGenerator","generatorOptions","_generatorOptions","_generatorOptions$def","defaultModifiers","_generatorOptions$def2","defaultOptions","createPopper","reference","popper","options","state","orderedModifiers","Object","assign","modifiersData","elements","attributes","styles","effectCleanupFns","isDestroyed","instance","setOptions","setOptionsAction","cleanupModifierEffects","scrollParents","contextElement","concat","filter","m","enabled","process","env","NODE_ENV","_ref","name","flipModifier","find","_ref2","console","error","join","_getComputedStyle","marginTop","marginRight","marginBottom","marginLeft","margin","parseFloat","warn","runModifierEffects","update","forceUpdate","_state$elements","rects","reset","forEach","modifier","data","__debug_loops__","index","_state$orderedModifie","fn","_state$orderedModifie2","_options","Promise","resolve","destroy","then","onFirstUpdate","_ref3","_ref3$options","effect","cleanupFn","noopFn","push"],"sources":["/home/vasu/Gsoc/website/project/node_modules/@popperjs/core/lib/createPopper.js"],"sourcesContent":["import getCompositeRect from \"./dom-utils/getCompositeRect.js\";\nimport getLayoutRect from \"./dom-utils/getLayoutRect.js\";\nimport listScrollParents from \"./dom-utils/listScrollParents.js\";\nimport getOffsetParent from \"./dom-utils/getOffsetParent.js\";\nimport getComputedStyle from \"./dom-utils/getComputedStyle.js\";\nimport orderModifiers from \"./utils/orderModifiers.js\";\nimport debounce from \"./utils/debounce.js\";\nimport validateModifiers from \"./utils/validateModifiers.js\";\nimport uniqueBy from \"./utils/uniqueBy.js\";\nimport getBasePlacement from \"./utils/getBasePlacement.js\";\nimport mergeByName from \"./utils/mergeByName.js\";\nimport detectOverflow from \"./utils/detectOverflow.js\";\nimport { isElement } from \"./dom-utils/instanceOf.js\";\nimport { auto } from \"./enums.js\";\nvar INVALID_ELEMENT_ERROR = 'Popper: Invalid reference or popper argument provided. They must be either a DOM element or virtual element.';\nvar INFINITE_LOOP_ERROR = 'Popper: An infinite loop in the modifiers cycle has been detected! The cycle has been interrupted to prevent a browser crash.';\nvar DEFAULT_OPTIONS = {\n  placement: 'bottom',\n  modifiers: [],\n  strategy: 'absolute'\n};\n\nfunction areValidElements() {\n  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n    args[_key] = arguments[_key];\n  }\n\n  return !args.some(function (element) {\n    return !(element && typeof element.getBoundingClientRect === 'function');\n  });\n}\n\nexport function popperGenerator(generatorOptions) {\n  if (generatorOptions === void 0) {\n    generatorOptions = {};\n  }\n\n  var _generatorOptions = generatorOptions,\n      _generatorOptions$def = _generatorOptions.defaultModifiers,\n      defaultModifiers = _generatorOptions$def === void 0 ? [] : _generatorOptions$def,\n      _generatorOptions$def2 = _generatorOptions.defaultOptions,\n      defaultOptions = _generatorOptions$def2 === void 0 ? DEFAULT_OPTIONS : _generatorOptions$def2;\n  return function createPopper(reference, popper, options) {\n    if (options === void 0) {\n      options = defaultOptions;\n    }\n\n    var state = {\n      placement: 'bottom',\n      orderedModifiers: [],\n      options: Object.assign({}, DEFAULT_OPTIONS, defaultOptions),\n      modifiersData: {},\n      elements: {\n        reference: reference,\n        popper: popper\n      },\n      attributes: {},\n      styles: {}\n    };\n    var effectCleanupFns = [];\n    var isDestroyed = false;\n    var instance = {\n      state: state,\n      setOptions: function setOptions(setOptionsAction) {\n        var options = typeof setOptionsAction === 'function' ? setOptionsAction(state.options) : setOptionsAction;\n        cleanupModifierEffects();\n        state.options = Object.assign({}, defaultOptions, state.options, options);\n        state.scrollParents = {\n          reference: isElement(reference) ? listScrollParents(reference) : reference.contextElement ? listScrollParents(reference.contextElement) : [],\n          popper: listScrollParents(popper)\n        }; // Orders the modifiers based on their dependencies and `phase`\n        // properties\n\n        var orderedModifiers = orderModifiers(mergeByName([].concat(defaultModifiers, state.options.modifiers))); // Strip out disabled modifiers\n\n        state.orderedModifiers = orderedModifiers.filter(function (m) {\n          return m.enabled;\n        }); // Validate the provided modifiers so that the consumer will get warned\n        // if one of the modifiers is invalid for any reason\n\n        if (process.env.NODE_ENV !== \"production\") {\n          var modifiers = uniqueBy([].concat(orderedModifiers, state.options.modifiers), function (_ref) {\n            var name = _ref.name;\n            return name;\n          });\n          validateModifiers(modifiers);\n\n          if (getBasePlacement(state.options.placement) === auto) {\n            var flipModifier = state.orderedModifiers.find(function (_ref2) {\n              var name = _ref2.name;\n              return name === 'flip';\n            });\n\n            if (!flipModifier) {\n              console.error(['Popper: \"auto\" placements require the \"flip\" modifier be', 'present and enabled to work.'].join(' '));\n            }\n          }\n\n          var _getComputedStyle = getComputedStyle(popper),\n              marginTop = _getComputedStyle.marginTop,\n              marginRight = _getComputedStyle.marginRight,\n              marginBottom = _getComputedStyle.marginBottom,\n              marginLeft = _getComputedStyle.marginLeft; // We no longer take into account `margins` on the popper, and it can\n          // cause bugs with positioning, so we'll warn the consumer\n\n\n          if ([marginTop, marginRight, marginBottom, marginLeft].some(function (margin) {\n            return parseFloat(margin);\n          })) {\n            console.warn(['Popper: CSS \"margin\" styles cannot be used to apply padding', 'between the popper and its reference element or boundary.', 'To replicate margin, use the `offset` modifier, as well as', 'the `padding` option in the `preventOverflow` and `flip`', 'modifiers.'].join(' '));\n          }\n        }\n\n        runModifierEffects();\n        return instance.update();\n      },\n      // Sync update – it will always be executed, even if not necessary. This\n      // is useful for low frequency updates where sync behavior simplifies the\n      // logic.\n      // For high frequency updates (e.g. `resize` and `scroll` events), always\n      // prefer the async Popper#update method\n      forceUpdate: function forceUpdate() {\n        if (isDestroyed) {\n          return;\n        }\n\n        var _state$elements = state.elements,\n            reference = _state$elements.reference,\n            popper = _state$elements.popper; // Don't proceed if `reference` or `popper` are not valid elements\n        // anymore\n\n        if (!areValidElements(reference, popper)) {\n          if (process.env.NODE_ENV !== \"production\") {\n            console.error(INVALID_ELEMENT_ERROR);\n          }\n\n          return;\n        } // Store the reference and popper rects to be read by modifiers\n\n\n        state.rects = {\n          reference: getCompositeRect(reference, getOffsetParent(popper), state.options.strategy === 'fixed'),\n          popper: getLayoutRect(popper)\n        }; // Modifiers have the ability to reset the current update cycle. The\n        // most common use case for this is the `flip` modifier changing the\n        // placement, which then needs to re-run all the modifiers, because the\n        // logic was previously ran for the previous placement and is therefore\n        // stale/incorrect\n\n        state.reset = false;\n        state.placement = state.options.placement; // On each update cycle, the `modifiersData` property for each modifier\n        // is filled with the initial data specified by the modifier. This means\n        // it doesn't persist and is fresh on each update.\n        // To ensure persistent data, use `${name}#persistent`\n\n        state.orderedModifiers.forEach(function (modifier) {\n          return state.modifiersData[modifier.name] = Object.assign({}, modifier.data);\n        });\n        var __debug_loops__ = 0;\n\n        for (var index = 0; index < state.orderedModifiers.length; index++) {\n          if (process.env.NODE_ENV !== \"production\") {\n            __debug_loops__ += 1;\n\n            if (__debug_loops__ > 100) {\n              console.error(INFINITE_LOOP_ERROR);\n              break;\n            }\n          }\n\n          if (state.reset === true) {\n            state.reset = false;\n            index = -1;\n            continue;\n          }\n\n          var _state$orderedModifie = state.orderedModifiers[index],\n              fn = _state$orderedModifie.fn,\n              _state$orderedModifie2 = _state$orderedModifie.options,\n              _options = _state$orderedModifie2 === void 0 ? {} : _state$orderedModifie2,\n              name = _state$orderedModifie.name;\n\n          if (typeof fn === 'function') {\n            state = fn({\n              state: state,\n              options: _options,\n              name: name,\n              instance: instance\n            }) || state;\n          }\n        }\n      },\n      // Async and optimistically optimized update – it will not be executed if\n      // not necessary (debounced to run at most once-per-tick)\n      update: debounce(function () {\n        return new Promise(function (resolve) {\n          instance.forceUpdate();\n          resolve(state);\n        });\n      }),\n      destroy: function destroy() {\n        cleanupModifierEffects();\n        isDestroyed = true;\n      }\n    };\n\n    if (!areValidElements(reference, popper)) {\n      if (process.env.NODE_ENV !== \"production\") {\n        console.error(INVALID_ELEMENT_ERROR);\n      }\n\n      return instance;\n    }\n\n    instance.setOptions(options).then(function (state) {\n      if (!isDestroyed && options.onFirstUpdate) {\n        options.onFirstUpdate(state);\n      }\n    }); // Modifiers have the ability to execute arbitrary code before the first\n    // update cycle runs. They will be executed in the same order as the update\n    // cycle. This is useful when a modifier adds some persistent data that\n    // other modifiers need to use, but the modifier is run after the dependent\n    // one.\n\n    function runModifierEffects() {\n      state.orderedModifiers.forEach(function (_ref3) {\n        var name = _ref3.name,\n            _ref3$options = _ref3.options,\n            options = _ref3$options === void 0 ? {} : _ref3$options,\n            effect = _ref3.effect;\n\n        if (typeof effect === 'function') {\n          var cleanupFn = effect({\n            state: state,\n            name: name,\n            instance: instance,\n            options: options\n          });\n\n          var noopFn = function noopFn() {};\n\n          effectCleanupFns.push(cleanupFn || noopFn);\n        }\n      });\n    }\n\n    function cleanupModifierEffects() {\n      effectCleanupFns.forEach(function (fn) {\n        return fn();\n      });\n      effectCleanupFns = [];\n    }\n\n    return instance;\n  };\n}\nexport var createPopper = /*#__PURE__*/popperGenerator(); // eslint-disable-next-line import/no-unused-modules\n\nexport { detectOverflow };"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}