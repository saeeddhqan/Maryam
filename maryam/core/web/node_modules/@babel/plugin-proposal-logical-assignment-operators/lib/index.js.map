{"version":3,"names":["declare","api","assertVersion","name","inherits","syntaxLogicalAssignmentOperators","default","visitor","AssignmentExpression","path","node","scope","operator","left","right","operatorTrunc","slice","t","LOGICAL_OPERATORS","includes","lhs","cloneNode","isMemberExpression","object","property","computed","memo","maybeGenerateMemoised","assignmentExpression","replaceWith","logicalExpression"],"sources":["../src/index.ts"],"sourcesContent":["import { declare } from \"@babel/helper-plugin-utils\";\nimport syntaxLogicalAssignmentOperators from \"@babel/plugin-syntax-logical-assignment-operators\";\nimport { types as t } from \"@babel/core\";\n\nexport default declare(api => {\n  api.assertVersion(7);\n\n  return {\n    name: \"proposal-logical-assignment-operators\",\n    inherits: syntaxLogicalAssignmentOperators.default,\n\n    visitor: {\n      AssignmentExpression(path) {\n        const { node, scope } = path;\n        const { operator, left, right } = node;\n        const operatorTrunc = operator.slice(0, -1);\n        if (!t.LOGICAL_OPERATORS.includes(operatorTrunc)) {\n          return;\n        }\n\n        const lhs = t.cloneNode(left) as t.Identifier | t.MemberExpression;\n        if (t.isMemberExpression(left)) {\n          const { object, property, computed } = left;\n          const memo = scope.maybeGenerateMemoised(object);\n          if (memo) {\n            left.object = memo;\n            (lhs as t.MemberExpression).object = t.assignmentExpression(\n              \"=\",\n              t.cloneNode(memo),\n              // object must not be Super when `memo` is an identifier\n              // eslint-disable-next-line @typescript-eslint/no-unnecessary-type-assertion\n              object as t.Expression,\n            );\n          }\n\n          if (computed) {\n            const memo = scope.maybeGenerateMemoised(property);\n            if (memo) {\n              left.property = memo;\n              (lhs as t.MemberExpression).property = t.assignmentExpression(\n                \"=\",\n                t.cloneNode(memo),\n                // @ts-expect-error todo(flow->ts): property can be t.PrivateName\n                property,\n              );\n            }\n          }\n        }\n\n        path.replaceWith(\n          t.logicalExpression(\n            // @ts-expect-error operatorTrunc has been tested by t.LOGICAL_OPERATORS\n            operatorTrunc,\n            lhs,\n            t.assignmentExpression(\"=\", left, right),\n          ),\n        );\n      },\n    },\n  };\n});\n"],"mappings":";;;;;;AAAA;AACA;AACA;AAAyC,eAE1B,IAAAA,0BAAO,EAACC,GAAG,IAAI;EAC5BA,GAAG,CAACC,aAAa,CAAC,CAAC,CAAC;EAEpB,OAAO;IACLC,IAAI,EAAE,uCAAuC;IAC7CC,QAAQ,EAAEC,uCAAgC,CAACC,OAAO;IAElDC,OAAO,EAAE;MACPC,oBAAoB,CAACC,IAAI,EAAE;QACzB,MAAM;UAAEC,IAAI;UAAEC;QAAM,CAAC,GAAGF,IAAI;QAC5B,MAAM;UAAEG,QAAQ;UAAEC,IAAI;UAAEC;QAAM,CAAC,GAAGJ,IAAI;QACtC,MAAMK,aAAa,GAAGH,QAAQ,CAACI,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;QAC3C,IAAI,CAACC,WAAC,CAACC,iBAAiB,CAACC,QAAQ,CAACJ,aAAa,CAAC,EAAE;UAChD;QACF;QAEA,MAAMK,GAAG,GAAGH,WAAC,CAACI,SAAS,CAACR,IAAI,CAAsC;QAClE,IAAII,WAAC,CAACK,kBAAkB,CAACT,IAAI,CAAC,EAAE;UAC9B,MAAM;YAAEU,MAAM;YAAEC,QAAQ;YAAEC;UAAS,CAAC,GAAGZ,IAAI;UAC3C,MAAMa,IAAI,GAAGf,KAAK,CAACgB,qBAAqB,CAACJ,MAAM,CAAC;UAChD,IAAIG,IAAI,EAAE;YACRb,IAAI,CAACU,MAAM,GAAGG,IAAI;YACjBN,GAAG,CAAwBG,MAAM,GAAGN,WAAC,CAACW,oBAAoB,CACzD,GAAG,EACHX,WAAC,CAACI,SAAS,CAACK,IAAI,CAAC;YAGjBH,MAAM,CACP;UACH;UAEA,IAAIE,QAAQ,EAAE;YACZ,MAAMC,IAAI,GAAGf,KAAK,CAACgB,qBAAqB,CAACH,QAAQ,CAAC;YAClD,IAAIE,IAAI,EAAE;cACRb,IAAI,CAACW,QAAQ,GAAGE,IAAI;cACnBN,GAAG,CAAwBI,QAAQ,GAAGP,WAAC,CAACW,oBAAoB,CAC3D,GAAG,EACHX,WAAC,CAACI,SAAS,CAACK,IAAI,CAAC;cAEjBF,QAAQ,CACT;YACH;UACF;QACF;QAEAf,IAAI,CAACoB,WAAW,CACdZ,WAAC,CAACa,iBAAiB;QAEjBf,aAAa,EACbK,GAAG,EACHH,WAAC,CAACW,oBAAoB,CAAC,GAAG,EAAEf,IAAI,EAAEC,KAAK,CAAC,CACzC,CACF;MACH;IACF;EACF,CAAC;AACH,CAAC,CAAC;AAAA"}